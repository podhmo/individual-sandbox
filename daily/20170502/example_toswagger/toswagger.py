import copy
from dictknife import loading
from collections import defaultdict


def resolve_type(val):
    if val is None:
        return "any"  # xxx: invalid as swagger
    if isinstance(val, str):
        return "string"
    elif isinstance(val, int):
        return "integer"
    elif isinstance(val, float):
        return "number"
    elif isinstance(val, bool):
        return "boolean"
    elif hasattr(val, "keys"):
        return "object"
    elif isinstance(val, (list, tuple)):
        return "array"
    else:
        raise ValueError("unsupported for {!r}".format(val))


class Detector:
    def make_info(self):
        return {"freq": 0, "type": None, "children": defaultdict(self.make_info)}

    def detect(self, d, name):
        s = defaultdict(self.make_info)
        self._detect(d, s[name], name)
        return s[name]

    def _detect(self, d, s, name):
        if hasattr(d, "keys"):
            s["type"] = "object"
            s["name"] = name
            s["freq"] += 1
            for k, v in d.items():
                self._detect(v, s["children"][k], k)
        elif isinstance(d, (list, tuple)):
            s["type2"] = "array"
            for x in d:
                self._detect(x, s, name)  # xxx
        else:
            typ = resolve_type(d)
            s["name"] = name
            s["freq"] += 1
            s["type"] = typ


class Emitter:
    def make_schema(self, info):
        if info.get("type2") == "array":
            return self.make_array_schema(info)
        elif info.get("type") == "object":
            return self.make_object_schema(info)
        else:
            return self.make_primitive_schema(info)

    def make_array_schema(self, info):
        d = {"type": "array"}
        copied = copy.deepcopy(info)
        copied.pop("type2")
        d["items"] = self.make_schema(copied)
        return d

    def make_object_schema(self, info):
        d = {"type": "object", "properties": {}}
        props = d["properties"]
        for name, value in info["children"].items():
            props[name] = self.make_schema(value)
        return d

    def make_primitive_schema(self, info):
        return {"type": info["type"]}

    def emit(self, root):
        return self.make_schema(root)


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--name", type=str, default="AutoGenerated")
    parser.add_argument("src", type=argparse.FileType('r'))
    args = parser.parse_args()

    loading.setup()
    data = loading.load(args.src)
    detector = Detector()
    emitter = Emitter()
    from dictknife import pp
    info = detector.detect(data, "*root*")
    schema = emitter.emit(info)
    pp(schema)

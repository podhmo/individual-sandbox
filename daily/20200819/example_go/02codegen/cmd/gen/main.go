package main

import (
	"bytes"
	"fmt"
	"go/token"
	"go/types"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

// TODO: support map, slice in import
// TODO: info of used method

func main() {
	if err := run(os.Args[1:]); err != nil {
		log.Fatalf("!!%+v", err)
	}
}

var (
	defHeader = template.Must(template.New("header").Parse(`
package {{.Pkg}}

// Generated by cmd/gen/main.go

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"testing"
{{- range $path := .ImportPaths }}
	{{$path}}
{{- end}}
)

// Suite: generated
type Suite struct {
	t *testing.T
	Pool pool // please, define by hand
}

// pool: needed for tests
type pool interface {
{{- range $x := .Needed}}
	{{$x.Name}}() {{$x.Type}}
{{- end}}
}

// renderWith: generated?
func (s *Suite) renderWith(t *testing.T, use func(t *testing.T, n *Notificator)) {
	t.Helper()
	n := &Notificator{Client: &FakeClient{}}
	use(t, n)
	AssertWithBox(t, n, func(box Box) {
		t.Helper()
		if box.Empty() {
			t.Fatal("unexpected empty")
			return
		}

		wpath := filepath.Join("testdata", t.Name())
		os.MkdirAll(filepath.Dir(wpath), 0744)

		t.Logf("write: %s", wpath)
		f, err := os.Create(wpath)
		if err != nil {
			t.Fatalf("!%+v", err)
		}

		fmt.Fprintf(f, "channel: %s\n", box[0].Channel)
		fmt.Fprintln(f, box[0].Text)
		defer f.Close()
	})
}
`))
	defMethod = template.Must(template.New("method").Parse(`
// Render{{.Name}}: generated
func (s *Suite) Render{{.Name}}(t *testing.T) {
	t.Helper()
	s.renderWith(t, func(t *testing.T, n *Notificator) {
{{- .InnerCode}}
		if err := n.{{.Name}}({{.InnerArguments}}); err != nil {
			t.Fatal(err)
		}
	})
}
`))
	defRun = template.Must(template.New("Run").Parse(`
// Test{{.Name}}: 
func Test{{.Name}}(t *testing.T){
	s, teardown := NewSuite(t)
	defer teardown()
{{range $mname := .Methods}}
	t.Run("{{$mname}}", s.Render{{$mname}})
{{- end}}
}
`))
)

func run(args []string) error {
	path := args[0]         // m/send
	pkgName := args[1]      // send
	targetName := args[2]   // Notificator
	methodPrefix := args[3] // Notify

	var o io.Writer
	if ok, _ := strconv.ParseBool(os.Getenv("VERBOSE")); ok {
		o = os.Stdout
	} else {
		o = bytes.NewBuffer(nil)
	}

	fset := token.NewFileSet()
	cfg := &packages.Config{
		Fset: fset,
		Mode: packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo,
	}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		return err
	}
	if len(pkgs) < 1 {
		return fmt.Errorf("something wrong: must be len(pkgs) == 1, but %d", len(pkgs))
	}

	pkg := pkgs[0]
	s := pkg.Types.Scope()
	ob := s.Lookup(targetName)

	log.SetFlags(log.LstdFlags)
	log.Println("pkg:", pkg, pkg.PkgPath)
	log.Println("names:", s.Names())
	log.Println("found object:", ob)

	named := ob.Type().(*types.Named)

	var actions []func() error
	var importPaths []string
	importPathsPtr := &importPaths
	seenPaths := map[string]bool{}
	addImportPath := func(path string) {
		if ok := seenPaths[path]; ok {
			return
		}
		log.Println("    found additional imports:", path)
		seenPaths[path] = true
		*importPathsPtr = append(*importPathsPtr, path)
	}
	var visitType func(types.Type, []types.Type)
	visitType = func(typ types.Type, visited []types.Type) {
		for _, t := range visited {
			if t == typ {
				// cycle to typ
				return
			}
		}
		visited = append(visited, typ)

		switch t := typ.(type) {
		case nil:
			return
		case *types.Basic:
			return
		case *types.Array:
			visitType(t.Elem(), visited)
			return
		case *types.Slice:
			visitType(t.Elem(), visited)
			return
		case *types.Struct:
			return // skip?
		case *types.Pointer:
			visitType(t.Elem(), visited)
			return
		case *types.Tuple:
			for i := 0; i < t.Len(); i++ {
				v := t.At(i)
				visitType(v.Type(), visited)
			}
		case *types.Signature:
			visitType(t.Params(), visited)
			visitType(t.Results(), visited)
			return
		case *types.Interface:
			return // skip?
		case *types.Map:
			visitType(t.Key(), visited)
			visitType(t.Elem(), visited)
			return
		case *types.Chan:
			visitType(t.Elem(), visited)
			return
		case *types.Named:
			path := t.Obj().Pkg().Path()
			addImportPath(fmt.Sprintf("%s %q", strings.ReplaceAll(path, "/", "_"), path))
		default:
			return
		}
	}

	type pair struct {
		Name string
		Type string
	}
	var needed []pair
	neededPtr := &needed

	seenNeeded := map[string]bool{}
	addNeeded := func(p pair) {
		if _, ok := seenNeeded[p.Name]; ok {
			return
		}
		log.Println("    found needed:", p.Name)
		seenNeeded[p.Name] = true
		*neededPtr = append(*neededPtr, p)
	}
	actions = append(actions, func() error {
		return defHeader.Execute(o, map[string]interface{}{
			"Pkg":         pkgName,
			"ImportPaths": *importPathsPtr,
			"Needed":      *neededPtr,
		})
	})

	var methods []string

	for i := 0; i < named.NumMethods(); i++ {
		method := named.Method(i)
		if !method.Exported() {
			continue
		}
		if !strings.HasPrefix(method.Name(), methodPrefix) {
			log.Println("skip", method.Name())
			continue
		}
		log.Printf("  found method: %s()", method.Name())

		sig, ok := method.Type().(*types.Signature)
		if !ok {
			return fmt.Errorf("%s is not signature %T", method, method.Type())
		}

		var args []string
		code := []string{""}

		for j := 0; j < sig.Params().Len(); j++ {
			x := sig.Params().At(j)

			if x.Type().String() == "context.Context" {
				code = append(code, fmt.Sprintf(`%s := context.Background()`, x.Name()))
				args = append(args, x.Name())
				continue
			}

			// TODO: find by name before find by type
			// TODO: support map,slice,array
			fullTypeName := x.Type().String()
			splitted := strings.Split(fullTypeName, ".")
			methodName := splitted[len(splitted)-1]

			isBultins := !strings.Contains(fullTypeName, ".")
			isExtraImport := !strings.HasPrefix(strings.TrimLeft(fullTypeName, "*"), pkg.Types.Path()+".")
			if isBultins {
				methodName = strings.ToUpper(x.Name())
			}

			code = append(code, fmt.Sprintf(`%s := s.Pool.%s()`, x.Name(), methodName))
			i := 0
			// for pointer
			for {
				if !strings.HasPrefix(fullTypeName[i:], "*") {
					break
				}
				i++
				code = append(code,
					fmt.Sprintf(`%s%s := &%s%s`,
						x.Name(), strings.Repeat("Ptr", i),
						x.Name(), strings.Repeat("Ptr", i-1),
					))
			}
			args = append(args, fmt.Sprintf(`%s%s`, x.Name(), strings.Repeat("Ptr", i)))

			// todo: extract *types.Package from types.Type
			// log.Printf("same? %v %v %v", x.Type(), pkg.Types.Path(), strings.HasPrefix(strings.TrimLeft(x.Type().String(), "*"), pkg.Types.Path()+"."))
			if isBultins {
				addNeeded(pair{Name: methodName, Type: fullTypeName})
			} else if !isExtraImport {
				addNeeded(pair{Name: methodName, Type: methodName})
			} else { // extra imports
				visitType(x.Type(), nil)
				addNeeded(pair{
					Name: methodName,
					Type: strings.ReplaceAll(strings.TrimLeft(fullTypeName, "*"), "/", "_"),
				})
			}
		}

		actions = append(actions, func() error {
			return defMethod.Execute(o, map[string]interface{}{
				"Name":           method.Name(),
				"InnerCode":      strings.Join(code, "\n\t\t"),
				"InnerArguments": strings.Join(args, ", "),
			})
		})
		methods = append(methods, method.Name())
	}

	actions = append(actions, func() error {
		return defRun.Execute(o, map[string]interface{}{
			"Name":    "Render",
			"Methods": methods,
		})
	})

	for _, ac := range actions {
		if err := ac(); err != nil {
			return err
		}
	}
	return nil
}

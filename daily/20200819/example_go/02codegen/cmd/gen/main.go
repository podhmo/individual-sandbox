package main

import (
	"bytes"
	"fmt"
	"go/token"
	"go/types"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

func main() {
	if err := run(os.Args[1:]); err != nil {
		log.Fatalf("!!%+v", err)
	}
}

func run(args []string) error {
	path := args[0]    // send
	pkgName := args[1] // send

	var o io.Writer
	if ok, _ := strconv.ParseBool(os.Getenv("VERBOSE")); ok {
		o = os.Stdout
	} else {
		o = bytes.NewBuffer(nil)
	}

	fset := token.NewFileSet()
	cfg := &packages.Config{
		Fset: fset,
		Mode: packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo,
	}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		return err
	}
	if len(pkgs) < 1 {
		return fmt.Errorf("something wrong: must be len(pkgs) == 1, but %d", len(pkgs))
	}

	pkg := pkgs[0]
	s := pkg.Types.Scope()
	ob := s.Lookup("Notificator")

	log.SetFlags(log.LstdFlags)
	log.Println("pkg:", pkg, pkg.PkgPath)
	log.Println("names:", s.Names())
	log.Println("found:", ob)

	named := ob.Type().(*types.Named)

	defHeader := template.Must(template.New("header").Parse(`
package {{.Pkg}}

// Generated by cmd/gen/main.go

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"testing"
)

// Suite: generated
type Suite struct {
	t *testing.T
	Pool pool // please, define by hand
}

// renderWith: generated?
func (s *Suite) renderWith(t *testing.T, use func(t *testing.T, n *Notificator)) {
	t.Helper()
	n := &Notificator{Client: &FakeClient{}}
	use(t, n)
	AssertWithBox(t, n, func(box Box) {
		t.Helper()
		if box.Empty() {
			t.Fatal("unexpected empty")
			return
		}

		wpath := filepath.Join("testdata", t.Name())
		os.MkdirAll(filepath.Dir(wpath), 0744)

		t.Logf("write: %s", wpath)
		f, err := os.Create(wpath)
		if err != nil {
			t.Fatalf("!%+v", err)
		}

		fmt.Fprintf(f, "channel: %s\n", box[0].Channel)
		fmt.Fprintln(f, box[0].Text)
		defer f.Close()
	})
}
`))
	defMethod := template.Must(template.New("method").Parse(`
// Render{{.Name}}: generated
func (s *Suite) Render{{.Name}}(t *testing.T) {
	t.Helper()
	s.renderWith(t, func(t *testing.T, n *Notificator) {
{{- .InnerCode}}
		if err := n.{{.Name}}({{.InnerArguments}}); err != nil {
			t.Fatal(err)
		}
	})
}
`))
	defRun := template.Must(template.New("Run").Parse(`
// Test{{.Name}}: 
func Test{{.Name}}(t *testing.T){
	s, teardown := NewSuite(t)
	defer teardown()
{{range $mname := .Methods}}
	t.Run("{{$mname}}", s.Render{{$mname}})
{{- end}}
}
`))
	defFooter := template.Must(template.New("footer").Parse(`
type pool interface {
{{- range $x := .Needed}}
	{{$x.Name}}() {{$x.Type}}
{{- end}}
}
`))

	defHeader.Execute(o, map[string]interface{}{
		"Pkg": pkgName,
	})

	var methods []string
	type pair struct {
		Name string
		Type string
	}
	var needed []pair

	for i := 0; i < named.NumMethods(); i++ {
		method := named.Method(i)
		if !method.Exported() {
			continue
		}
		if !strings.HasPrefix(method.Name(), "Notify") {
			log.Println("skip", method.Name())
			continue
		}

		sig, ok := method.Type().(*types.Signature)
		if !ok {
			return fmt.Errorf("%s is not signature %T", method, method.Type())
		}

		var args []string
		code := []string{""}

		for j := 0; j < sig.Params().Len(); j++ {
			x := sig.Params().At(j)
			if x.Type().String() == "context.Context" {
				// TODO: import
				code = append(code, fmt.Sprintf(`%s := context.Background()`, x.Name()))
				args = append(args, x.Name())
			} else {
				// TODO: find by name before find by type
				fullTypename := x.Type().String()
				splitted := strings.Split(fullTypename, ".")
				typename := splitted[len(splitted)-1]
				code = append(code, fmt.Sprintf(`%s := s.Pool.%s()`, x.Name(), typename))
				i := 0
				// for pointer
				for {
					if !strings.HasPrefix(fullTypename[i:], "*") {
						break
					}
					i++
					code = append(code,
						fmt.Sprintf(`%s%s := &%s%s`,
							x.Name(), strings.Repeat("Ptr", i),
							x.Name(), strings.Repeat("Ptr", i-1),
						))
				}
				needed = append(needed, pair{Name: typename, Type: typename}) // TODO: fullpath
				args = append(args, fmt.Sprintf(`%s%s`, x.Name(), strings.Repeat("Ptr", i)))
			}
		}

		defMethod.Execute(o, map[string]interface{}{
			"Name":           method.Name(),
			"InnerCode":      strings.Join(code, "\n\t\t"),
			"InnerArguments": strings.Join(args, ", "),
		})
		methods = append(methods, method.Name())
	}

	defRun.Execute(o, map[string]interface{}{
		"Name":    "Render",
		"Methods": methods,
	})

	seen := map[string]bool{}
	var deduped []pair
	for _, p := range needed {
		p := p
		if ok := seen[p.Name]; ok {
			continue
		}
		seen[p.Name] = true
		deduped = append(deduped, p)
	}

	defFooter.Execute(o, map[string]interface{}{
		"Needed": deduped,
	})
	return nil
}

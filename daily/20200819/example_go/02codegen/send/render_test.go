package send

// Generated by cmd/gen/main.go

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"testing"
)

// Suite: generated
type Suite struct {
	t    *testing.T
	Pool pool // please, define by hand
}

// renderWith: generated?
func (s *Suite) renderWith(t *testing.T, use func(t *testing.T, n *Notificator)) {
	t.Helper()
	n := &Notificator{Client: &FakeClient{}}
	use(t, n)
	AssertWithBox(t, n, func(box Box) {
		t.Helper()
		if box.Empty() {
			t.Fatal("unexpected empty")
			return
		}

		wpath := filepath.Join("testdata", t.Name())
		os.MkdirAll(filepath.Dir(wpath), 0744)

		t.Logf("write: %s", wpath)
		f, err := os.Create(wpath)
		if err != nil {
			t.Fatalf("!%+v", err)
		}

		fmt.Fprintf(f, "channel: %s\n", box[0].Channel)
		fmt.Fprintln(f, box[0].Text)
		defer f.Close()
	})
}

// RenderNotifyRegistered: generated
func (s *Suite) RenderNotifyRegistered(t *testing.T) {
	t.Helper()
	s.renderWith(t, func(t *testing.T, n *Notificator) {
		ctx := context.Background()
		user := s.Pool.User()
		if err := n.NotifyRegistered(ctx, user); err != nil {
			t.Fatal(err)
		}
	})
}

// RenderNotifyCancelled: generated
func (s *Suite) RenderNotifyCancelled(t *testing.T) {
	t.Helper()
	s.renderWith(t, func(t *testing.T, n *Notificator) {
		ctx := context.Background()
		user := s.Pool.User()
		userPtr := &user
		if err := n.NotifyCancelled(ctx, userPtr); err != nil {
			t.Fatal(err)
		}
	})
}

// TestRender:
func TestRender(t *testing.T) {
	s, teardown := NewSuite(t)
	defer teardown()

	t.Run("NotifyRegistered", s.RenderNotifyRegistered)
	t.Run("NotifyCancelled", s.RenderNotifyCancelled)
}

type pool interface {
	User() User
}

package main

import (
	"fmt"
	"log"

	"github.com/podhmo/handwriting"
	"github.com/podhmo/handwriting/generator/lookup"
)

func run() error {
	p, err := handwriting.NewFromPackagePath("./me", handwriting.WithConsoleOutput())
	if err != nil {
		return err
	}
	p.Config.Import("./test")

	f := p.File("Stringer.go")
	f.Import("github.com/stretchr/testify/mock")
	f.Code(func(e *handwriting.Emitter) error {
		o := e.Output

		mockpkg := e.Prog.Package("github.com/stretchr/testify/mock").Pkg
		testpkg := e.Prog.Package("./test").Pkg

		target := testpkg.Scope().Lookup("Stringer")

		o.Printfln("// %s is an autogenerated mock type for the %s type", target.Name(), target.Name())
		o.WithBlock(fmt.Sprintf("type %s struct", target.Name()), func() {
			o.Println(e.File.TypeName(mockpkg.Scope().Lookup("Mock").Type()))
		})

		iface, err := lookup.AsInterface(target)
		if err != nil {
			return err
		}

		iface.IterateAllMethods(func(method *lookup.FuncRef) {
			o.Printfln("// %s provides a mock function with given fields", target.Name())
			o.WithBlock(fmt.Sprintf("func (_m %s) %s %s %s", target.Name(), method.Name(), e.File.TypeName(method.Signature.Params()), e.File.TypeNameForResults(method.Signature.Results())), func() {
				o.Println("ret := _m.Called()")

				o.Printfln("var r0 %s", e.File.TypeName(method.Signature.Results().At(0).Type()))
				o.WithIfAndElse("if rf, ok := ret.Get(0).(func() string); ok",
					func() {
						o.Println("r0 = rf()")
					},
					func() {
						o.Println("r0 = ret.Get(0).(string)")
					},
				)
				o.Println("return r0")
			})
		})
		return nil
	})
	return p.Emit()
}

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

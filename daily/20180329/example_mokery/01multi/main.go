package main

import (
	"fmt"
	"go/types"
	"log"
	"strings"

	"github.com/podhmo/handwriting"
	"github.com/podhmo/handwriting/generator/lookup"
	"github.com/podhmo/handwriting/generator/typesutil"
	"github.com/podhmo/handwriting/multifile"
)

func main() {
	srcpkg := "./test"
	name := "I"
	outpkg := "./me"
	if err := run(srcpkg, name, outpkg); err != nil {
		log.Fatal(err)
	}
}

func run(srcpkg, name, outpkg string) error {
	p, err := handwriting.NewFromPackagePath(outpkg, handwriting.WithOpener(multifile.Must(multifile.Dir(outpkg))))
	if err != nil {
		return err
	}
	p.Config.Import(srcpkg)

	f := p.File(fmt.Sprintf("%s.go", name))
	f.Import("github.com/stretchr/testify/mock")
	f.Code(func(e *handwriting.Emitter) error {
		o := e.Output

		// import pkg, if not imported yet.
		d := typesutil.NewPackageDetector(func(pkg *types.Package) {
			if pkg != nil {
				f.Import(pkg.Path())
			}
		})
		nilType := types.Universe.Lookup("nil").Type()
		errorType := types.Universe.Lookup("error").Type()

		mockpkg := e.Prog.Package("github.com/stretchr/testify/mock").Pkg
		testpkg := e.Prog.Package(srcpkg).Pkg

		target := testpkg.Scope().Lookup(name)

		o.Printfln("// %s is an autogenerated mock type for the %s type", target.Name(), target.Name())
		o.WithBlock(fmt.Sprintf("type %s struct", target.Name()), func() {
			o.Println(e.File.TypeName(mockpkg.Scope().Lookup("Mock").Type()))
		})

		iface, err := lookup.AsInterface(target)
		if err != nil {
			return err
		}

		iface.IterateAllMethods(func(method *lookup.FuncRef) {
			params := method.Signature.Params()
			paramvals := make([]string, params.Len())
			for i := range paramvals {
				d.Detect(params.At(i).Type())
				paramvals[i] = params.At(i).Name()
			}

			results := method.Signature.Results()
			retvals := make([]string, results.Len())
			for i := range retvals {
				d.Detect(results.At(i).Type())
				retvals[i] = fmt.Sprintf("r%d", i)
			}

			o.Printfln("// %s provides a mock function with given fields: %s", method.Name(), strings.Join(paramvals, ", "))
			o.WithBlock(fmt.Sprintf("func (_m *%s) %s%s %s", target.Name(), method.Name(), e.File.TypeName(params), e.File.TypeNameForResults(results)), func() {

				if params.Len() == 0 {
					o.Println("_m.Called()")
				} else {
					o.Printfln("ret := _m.Called(%s)", strings.Join(paramvals, ", "))
				}

				for i := 0; i < results.Len(); i++ {
					typ := results.At(i).Type()
					o.Printfln("var r%d %s", i, e.File.TypeName(typ))
					o.WithIfAndElse(fmt.Sprintf("rf, ok := ret.Get(%d).(func%s %s); ok", i, e.File.TypeName(params), e.File.TypeName(typ)),
						func() {
							o.Printfln("r%d = rf(%s)", i, strings.Join(paramvals, ", "))
						},
						func() {
							if types.Identical(typ, errorType) {
								o.Printfln("r%d = ret.Error(%d)", i, i)
								return
							}
							if types.AssignableTo(nilType, typ) {
								o.WithBlock(fmt.Sprintf("if ret.Get(%d) != nil", i), func() {
									o.Printfln("r%d = ret.Get(%d).(%s)", i, i, e.File.TypeName(typ))
								})
								return
							}
							o.Printfln("r%d = ret.Get(%d).(%s)", i, i, e.File.TypeName(typ))
						},
					)
				}

				if results.Len() > 0 {
					o.Printfln("return %s", strings.Join(retvals, ", "))
				}
			})
		})
		return nil
	})
	return p.Emit()
}

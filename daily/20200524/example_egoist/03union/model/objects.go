package model

import (
	"github.com/podhmo/maperr"
	"encoding/json"
	"fmt"
	"strings"
)

// this file is generated by egoist.generators.structkit

type W struct {
	XyUnionList []XorY `json:"xy_union_list"`
	XyListUnion XListorYList `json:"xy_list_union"`
}

func (w *W) UnmarshalJSON(b []byte) error {
	var err *maperr.Error

	// loading internal data
	var inner struct {
		XyUnionList *json.RawMessage `json:"xy_union_list"`// required
		XyListUnion *json.RawMessage `json:"xy_list_union"`// required
	}
	if rawErr := json.Unmarshal(b, &inner); rawErr != nil  {
		return err.AddSummary(rawErr.Error())
	}

	// binding field value and required check
	{
		if inner.XyUnionList != nil  {
			w.XyUnionList = []XorY{}
			if rawerr := json.Unmarshal(*inner.XyUnionList, &w.XyUnionList); rawerr != nil  {
				err = err.Add("xy_union_list", maperr.Message{Error: rawerr})
			}
		} else  {
			err = err.Add("xy_union_list", maperr.Message{Text: "required"})
		}
		if inner.XyListUnion != nil  {
			if rawerr := json.Unmarshal(*inner.XyListUnion, &w.XyListUnion); rawerr != nil  {
				err = err.Add("xy_list_union", maperr.Message{Error: rawerr})
			}
		} else  {
			err = err.Add("xy_list_union", maperr.Message{Text: "required"})
		}
	}

	return err.Untyped()
}

type XListorYList struct {
	Kind XListorYListKind `json:"$kind"` // discriminator
	[]X *[]X `json:"[]X,omitempty"`
	[]Y *[]Y `json:"[]Y,omitempty"`
}

func (x *XListorYList) UnmarshalJSON(b []byte) error {
	var err *maperr.Error

	// loading internal data
	var inner struct {
		Kind *XListorYListKind `json:"$kind"`// required
		XList *json.RawMessage `json:"XList"`
		YList *json.RawMessage `json:"YList"`
	}
	if rawErr := json.Unmarshal(b, &inner); rawErr != nil  {
		return err.AddSummary(rawErr.Error())
	}

	// binding field value and required check
	{
		if inner.Kind != nil  {
			x.Kind = *inner.Kind
		} else  {
			err = err.Add("$kind", maperr.Message{Text: "required"})
		}
		if inner.XList != nil  {
			x.XList = &[]X{}
			if rawerr := json.Unmarshal(*inner.XList, x.XList); rawerr != nil  {
				err = err.Add("XList", maperr.Message{Error: rawerr})
			}
		}
		if inner.YList != nil  {
			x.YList = &[]Y{}
			if rawerr := json.Unmarshal(*inner.YList, x.YList); rawerr != nil  {
				err = err.Add("YList", maperr.Message{Error: rawerr})
			}
		}
	}

	// one-of?
	{
		if x.Kind == "XList" && x.XList == nil  {
			err = err.Add("XList", maperr.Message{Text: "treated as XList, but no data"})
		}
		if x.Kind == "YList" && x.YList == nil  {
			err = err.Add("YList", maperr.Message{Text: "treated as YList, but no data"})
		}
	}
	return err.Untyped()
}

type XListorYListKind GenericAlias

const (
	XListorYListKindXList XListorYListKind = "XList"
	XListorYListKindYList XListorYListKind = "YList"
)


func (v XListorYListKind) Valid() error {
	switch v {
	case XListorYListKindXList, XListorYListKindYList:
		return nil
	default:
		return fmt.Errorf("%q is invalid enum value of (XList, YList)", v)
	}
}

func (v *XListorYListKind) UnmarshalJSON(b []byte) error {
	*v = XListorYListKind(strings.Trim(string(b), `"`))
	return v.Valid()
}


type X struct {
	Name string `json:"name"`
}

func (x *X) UnmarshalJSON(b []byte) error {
	var err *maperr.Error

	// loading internal data
	var inner struct {
		Name *string `json:"name"`// required
	}
	if rawErr := json.Unmarshal(b, &inner); rawErr != nil  {
		return err.AddSummary(rawErr.Error())
	}

	// binding field value and required check
	{
		if inner.Name != nil  {
			x.Name = *inner.Name
		} else  {
			err = err.Add("name", maperr.Message{Text: "required"})
		}
	}

	return err.Untyped()
}

type Y struct {
	Name string `json:"name"`
	Memo string `json:"memo"`
}

func (y *Y) UnmarshalJSON(b []byte) error {
	var err *maperr.Error

	// loading internal data
	var inner struct {
		Name *string `json:"name"`// required
		Memo *string `json:"memo"`// required
	}
	if rawErr := json.Unmarshal(b, &inner); rawErr != nil  {
		return err.AddSummary(rawErr.Error())
	}

	// binding field value and required check
	{
		if inner.Name != nil  {
			y.Name = *inner.Name
		} else  {
			err = err.Add("name", maperr.Message{Text: "required"})
		}
		if inner.Memo != nil  {
			y.Memo = *inner.Memo
		} else  {
			err = err.Add("memo", maperr.Message{Text: "required"})
		}
	}

	return err.Untyped()
}
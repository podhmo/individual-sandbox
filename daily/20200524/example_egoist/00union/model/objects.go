package model

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/podhmo/maperr"
)

// this file is generated by egoist.generators.structkit

type W struct {
	XyUnionList []XorY       `json:"xy_union_list"`
	XyListUnion XListOrYList `json:"xy_list_union"`
}

func (w *W) UnmarshalJSON(b []byte) error {
	var err *maperr.Error

	// loading internal data
	var inner struct {
		XyUnionList *json.RawMessage `json:"xy_union_list"` // required
		XyListUnion *json.RawMessage `json:"xy_list_union"` // required
	}
	if rawErr := json.Unmarshal(b, &inner); rawErr != nil {
		return err.AddSummary(rawErr.Error())
	}

	// binding field value and required check
	{
		if inner.XyUnionList != nil {
			w.XyUnionList = []XorY{}
			if rawerr := json.Unmarshal(*inner.XyUnionList, &w.XyUnionList); rawerr != nil {
				err = err.Add("xy_union_list", maperr.Message{Error: rawerr})
			}
		} else {
			err = err.Add("xy_union_list", maperr.Message{Text: "required"})
		}
		if inner.XyListUnion != nil {
			if rawerr := json.Unmarshal(*inner.XyListUnion, &w.XyListUnion); rawerr != nil {
				err = err.Add("xy_list_union", maperr.Message{Error: rawerr})
			}
		} else {
			err = err.Add("xy_list_union", maperr.Message{Text: "required"})
		}
	}

	return err.Untyped()
}

type XorY struct {
	Kind XorYKind `json:"$kind"` // discriminator
	X    *X       `json:"x,omitempty"`
	Y    *Y       `json:"y,omitempty"`
}

func (x *XorY) UnmarshalJSON(b []byte) error {
	var err *maperr.Error

	// loading internal data
	var inner struct {
		Kind *XorYKind        `json:"$kind"` // required
		X    *json.RawMessage `json:"X"`
		Y    *json.RawMessage `json:"Y"`
	}
	if rawErr := json.Unmarshal(b, &inner); rawErr != nil {
		return err.AddSummary(rawErr.Error())
	}

	// binding field value and required check
	{
		if inner.Kind != nil {
			x.Kind = *inner.Kind
		} else {
			err = err.Add("$kind", maperr.Message{Text: "required"})
		}
		if inner.X != nil {
			x.X = &X{}
			if rawerr := json.Unmarshal(*inner.X, x.X); rawerr != nil {
				err = err.Add("X", maperr.Message{Error: rawerr})
			}
		}
		if inner.Y != nil {
			x.Y = &Y{}
			if rawerr := json.Unmarshal(*inner.Y, x.Y); rawerr != nil {
				err = err.Add("Y", maperr.Message{Error: rawerr})
			}
		}
	}

	// one-of?
	{
		if x.Kind == "X" && x.X == nil {
			err = err.Add("X", maperr.Message{Text: "treated as X, but no data"})
		}
		if x.Kind == "Y" && x.Y == nil {
			err = err.Add("Y", maperr.Message{Text: "treated as Y, but no data"})
		}
	}
	return err.Untyped()
}

type XorYKind string

const (
	XorYKindX XorYKind = "X"
	XorYKindY XorYKind = "Y"
)

func (v XorYKind) Valid() error {
	switch v {
	case XorYKindX, XorYKindY:
		return nil
	default:
		return fmt.Errorf("%q is invalid enum value of (X, Y)", v)
	}
}

func (v *XorYKind) UnmarshalJSON(b []byte) error {
	*v = XorYKind(strings.Trim(string(b), `"`))
	return v.Valid()
}

type XListOrYList struct {
	Kind XListOrYListKind `json:"$kind"` // discriminator
	X    *[]X             `json:"[]X,omitempty"`
	Y    *[]Y             `json:"[]Y,omitempty"`
}

func (x *XListOrYList) UnmarshalJSON(b []byte) error {
	var err *maperr.Error

	// loading internal data
	var inner struct {
		Kind  *XListOrYListKind `json:"$kind"` // required
		XList *json.RawMessage  `json:"XList"`
		YList *json.RawMessage  `json:"YList"`
	}
	if rawErr := json.Unmarshal(b, &inner); rawErr != nil {
		return err.AddSummary(rawErr.Error())
	}

	// binding field value and required check
	{
		if inner.Kind != nil {
			x.Kind = *inner.Kind
		} else {
			err = err.Add("$kind", maperr.Message{Text: "required"})
		}
		if inner.XList != nil {
			if rawerr := json.Unmarshal(*inner.XList, x.X); rawerr != nil {
				err = err.Add("XList", maperr.Message{Error: rawerr})
			}
		}
		if inner.YList != nil {
			if rawerr := json.Unmarshal(*inner.YList, x.Y); rawerr != nil {
				err = err.Add("YList", maperr.Message{Error: rawerr})
			}
		}
	}

	// one-of?
	{
		if x.Kind == "XList" && x.X == nil {
			err = err.Add("XList", maperr.Message{Text: "treated as XList, but no data"})
		}
		if x.Kind == "YList" && x.Y == nil {
			err = err.Add("YList", maperr.Message{Text: "treated as YList, but no data"})
		}
	}
	return err.Untyped()
}

type XListOrYListKind string

const (
	XListOrYListKindXList XListOrYListKind = "XList"
	XListOrYListKindYList XListOrYListKind = "YList"
)

func (v XListOrYListKind) Valid() error {
	switch v {
	case XListOrYListKindXList, XListOrYListKindYList:
		return nil
	default:
		return fmt.Errorf("%q is invalid enum value of (XList, YList)", v)
	}
}

func (v *XListOrYListKind) UnmarshalJSON(b []byte) error {
	*v = XListOrYListKind(strings.Trim(string(b), `"`))
	return v.Valid()
}

type X struct {
	Name string `json:"name"`
}

func (x *X) UnmarshalJSON(b []byte) error {
	var err *maperr.Error

	// loading internal data
	var inner struct {
		Name *string `json:"name"` // required
	}
	if rawErr := json.Unmarshal(b, &inner); rawErr != nil {
		return err.AddSummary(rawErr.Error())
	}

	// binding field value and required check
	{
		if inner.Name != nil {
			x.Name = *inner.Name
		} else {
			err = err.Add("name", maperr.Message{Text: "required"})
		}
	}

	return err.Untyped()
}

type Y struct {
	Name string `json:"name"`
	Memo string `json:"memo"`
}

func (y *Y) UnmarshalJSON(b []byte) error {
	var err *maperr.Error

	// loading internal data
	var inner struct {
		Name *string `json:"name"` // required
		Memo *string `json:"memo"` // required
	}
	if rawErr := json.Unmarshal(b, &inner); rawErr != nil {
		return err.AddSummary(rawErr.Error())
	}

	// binding field value and required check
	{
		if inner.Name != nil {
			y.Name = *inner.Name
		} else {
			err = err.Add("name", maperr.Message{Text: "required"})
		}
		if inner.Memo != nil {
			y.Memo = *inner.Memo
		} else {
			err = err.Add("memo", maperr.Message{Text: "required"})
		}
	}

	return err.Untyped()
}
